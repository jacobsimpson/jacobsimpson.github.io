'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/basic-plugin/','title':"A Basic Lua Plugin",'content':" A Basic Lua Plugin bash \\  \u0026lt;(curl -o- https://raw.githubusercontent.com/jacobsimpson/nvim-example-lua-plugin/master/install.sh) \\  mynewplugin TODO: There have been a lot of Neovim improvements, this example could probably use some updates. Also, if the luamodule was named myluamodule it would be just a little more obvious that the directory name/module name can be changed.\n"});index.add({'id':1,'href':'/docs/communicating/','title':"VimL to Lua and back",'content':" VimL to Lua and back There are different reasons for having VimScript and Lua code interact, such as calling existing functions, setting variables to configure other plugins, or Neovim. Below are descriptions of techniques for different kinds of interactions between VimScript and Lua.\nFrom Lua Accessing VimL Variables There are a couple of options.\nTo access global variables:\nlocal a = vim.api.nvim_get_var(\u0026#39;something\u0026#39;) vim.api.nvim_set_var(\u0026#39;something\u0026#39;, \u0026#39;value\u0026#39;) Which would appear in VimScript as:\necho g:something For v: variables, like the predefined v:servername:\necho v:servername becomes:\nprint(vim.api.nvim_get_vvar(\u0026#34;servername\u0026#34;)) And for general expression evaluation, which can include accessing variables:\nlocal servername = vim.api.nvim_eval(\u0026#34;v:servername\u0026#34;) Calling VimL Functions nvim_call_function(...) From VimScript Calling Lua Code from VimL nvim_execute_lua(...) "});index.add({'id':2,'href':'/docs/job-control/','title':"Job Control",'content':" Job Control vim.fn.jobstart(\u0026#34;ls\u0026#34;) Networking, Communication and Job Control How to use Neovim to send a message to a Running Neovim instance nvim --noplugin --cmd \u0026#34;lua vim.fn.rpcrequest(vim.fn.sockconnect(\u0026#39;pipe\u0026#39;, \u0026#39;/var/folders/nh/lwpxl66111j103y85rw0kdvw0000gn/T/nvimNdff2D/0\u0026#39;, { rpc = true }), \u0026#39;nvim_command\u0026#39;, \u0026#39;:e ~/.zshrc\u0026#39;)\u0026#34; --cmd \u0026#34;q\u0026#34; --headless "});index.add({'id':3,'href':'/docs/buffers-and-windows/','title':"Buffers and Windows",'content':" Buffers and Windows Setting Options When you set an option in Neovim, the syntax you may be accustom to, as a user, is :set nomodifiable, or :set buftype=nofile.\nWhen using the the Neovim API to set options, I\u0026rsquo;ve found a couple things to keep in mind.\n The option may be a buffer, window or global option, and there is a different API call for each. If you choose the wrong API, the API call will result in an error. So if you are trying to set an option, and you are getting an error indicating there is no such option, try a different API.\nvim.api.nvim_buf_set_option(buf, \u0026#39;modifiable\u0026#39;, false) vim.api.nvim_win_set_option(win, \u0026#39;winhighlight\u0026#39;, \u0026#39;Normal:Normal\u0026#39;) vim.api.nvim_set_option(\u0026#39;wrapscan\u0026#39;, false) The option values are type sensitive. Options prefixed with no are boolean values, i.e. :set nomodifiable translates to modifiable with a boolean value.\nvim.api.nvim_buf_set_option(0, \u0026#39;modifiable\u0026#39;, true)  Reading a Buffer Modifying a Buffer Clearing a Buffer vim.api.nvim_buf_set_lines(buf, 0, -1, true, {}) Replacing a Buffer vim.api.nvim_buf_set_lines(buf, 0, -1, true, {\u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;}) Appending to a Buffer vim.api.nvim_buf_set_lines(buf, -1, -1, true, {\u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;}) Setting Options on a Buffer To set options on the current buffer, use 0 as the first argument. To specify a buffer, use the value returned by nvim.api.nvim_create_buf() or nvim.api.nvim_list_bufs().\nvim.api.nvim_buf_set_option(0, \u0026#39;buftype\u0026#39;, \u0026#39;nofile\u0026#39;) vim.api.nvim_buf_set_option(0, \u0026#39;filetype\u0026#39;, \u0026#39;lua\u0026#39;) vim.api.nvim_buf_set_option(0, \u0026#39;modifiable\u0026#39;, true) The name of a buffer is not a standard option, and has it\u0026rsquo;s own function:\nvim.api.nvim_buf_set_name(buf, \u0026#39;my special buffer\u0026#39;) "});index.add({'id':4,'href':'/docs/interacting/','title':"Interacting with the User",'content':" Interacting with the User Echo To put a message at the bottom of the screen, and in the :messages buffer:\nprint(\u0026#34;Something really important.\u0026#34;) This is analogous to the echo command in VimScript.\nDisplaying something there is a confirm API method in Vim documentation that asks questions and returns the selected response.\nA Split A Floating Window A Floating Window with Borders At the moment this is no native support margins or borders on floating windows, so there is a work around to nest floating windows. It is outlined in VimScript here and converted into Lua here.\nfunction NavigationFloatingWin() -- get the editor\u0026#39;s max width and height local width = vim.api.nvim_get_option(\u0026#34;columns\u0026#34;) local height = vim.api.nvim_get_option(\u0026#34;lines\u0026#34;) -- create a new, scratch buffer, for fzf local buf = vim.api.nvim_create_buf(false, true) vim.api.nvim_buf_set_option(buf, \u0026#39;buftype\u0026#39;, \u0026#39;nofile\u0026#39;) -- if the editor is big enough if (width \u0026gt; 150 or height \u0026gt; 35) then -- fzf\u0026#39;s window height is 3/4 of the max height, but not more than 30 local win_height = math.min(math.ceil(height * 3 / 4), 30) local win_width -- if the width is small if (width \u0026lt; 150) then -- just subtract 8 from the editor\u0026#39;s width win_width = math.ceil(width - 8) else -- use 90% of the editor\u0026#39;s width win_width = math.ceil(width * 0.9) end -- settings for the fzf window local opts = { relative = \u0026#34;editor\u0026#34;, width = win_width, height = win_height, row = math.ceil((height - win_height) / 2), col = math.ceil((width - win_width) / 2) } -- create a new floating window, centered in the editor local win = vim.api.nvim_open_win(buf, true, opts) end end For a tool tip This uses Neovim\u0026rsquo;s new floating window capability to overlay a window. The window is backed by a buffer containing the two lines, \u0026ldquo;test\u0026rdquo; and \u0026ldquo;text\u0026rdquo;.\nlocal buf = vim.api.nvim_create_buf(false, true) vim.api.nvim_buf_set_lines(buf, 0, -1, true, {\u0026#34;test\u0026#34;, \u0026#34;text\u0026#34;}) local opts = { relative = \u0026#39;cursor\u0026#39;, width = 10, height = 2, col = 0, row = 1, anchor = \u0026#39;NW\u0026#39;, style = \u0026#39;minimal\u0026#39; } local win = vim.api.nvim_open_win(buf, 0, opts) -- optional: change highlight, otherwise Pmenu is used vim.api.nvim_win_set_option(win, \u0026#39;winhl\u0026#39;, \u0026#39;Normal:MyHighlight\u0026#39;) "});index.add({'id':5,'href':'/docs/basic-plugin/hidden/','title':"Hidden",'content':" This page is hidden in menu Quondam non pater est dignior ille Eurotas Latent te facies Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired));  "});index.add({'id':6,'href':'/categories/','title':"Categories",'content':""});index.add({'id':7,'href':'/docs/','title':"Docs",'content':""});index.add({'id':8,'href':'/','title':"Introduction",'content':" Building Neovim Plugins in Lua First To acknowledge, all this information is available somewhere, most of it in the Neovim :help documentation. I just find it easier to pull it all together. I\u0026rsquo;m not a proficient plugin writer, and when I do write a plugin, I\u0026rsquo;m just trying to quickly solve a problem and get back to work. I want a place to see examples and copy working code.\nI don\u0026rsquo;t really enjoy working in VimScript, so this is as much about Lua as possible. However, at heart, I am a pragmatist, so where it makes sense, I put things in VimScript. autocmd, key mappings, commands and the like. I don\u0026rsquo;t cover how to do any of that stuff in much depth here, there are much better resources available.\n"});index.add({'id':9,'href':'/tags/','title':"Tags",'content':""});})();